.. vim: syntax=rst

.. http://rolandpuntaier.blogspot.co.at/2017/04/infinity.html

.. {infinity}

So far I've blogged only about the finite `variable`_ and a `topological structure`_ (`FCA`_) 
on it:

- a `variable`_ is a set of exclusive values, created by a selection process
- variables live in a `lattice`_ of set containment (`topology`_, `FCA`_)
- an extensive value is a variable by itself

The last kind I explore in a separate `measure`_ blog.

Here I want to ponder over **infinity**,
how it can be integrated into the current understanding and what good it is for.

What is infinity?
-----------------

*Finite* variables have *finite* information. Do *infinite* variables have *infinite*
information? But that would mean a computer taking up all the universe would not 
suffice to store the values of an infinite variable or select a value thereof.
Infinity in this sense does not exist and therefore one can also not make 
any statements or conclusions that involve infinity.

The universe can be regarded as a parallel computer consisting of a myriad of,
but still finitely many, selection processes happening in parallel. Each of
these selections are from finite variables.

We, as an organism that survived by evolving adaptability through a brain
able to map the world and simulate it, need to be able to *generate* internal
variables that can be mapped to the real ones.

.. admonition:: Paradigm change to algorithms: generated variables

  Instead of regarding actual variables with a finite number of values we now
  start to look at algorithms to generate variables. 
  E.g. `â„•` is generated by looping +1 (=(+1)*).
  With this the size of a variable (space complexity) can be moved to the time
  domain (time complexity). This is not only a feature of the information
  processing brain but also of the world itself (`Î”EÎ”tâ‰¥h`) (`action`_, `h`_).

  A generated variable is versatile. It can be generated to the appropriate
  size, whatever the physical variable asks for.

Infinity is a construct of the mind and not of the physical reality.
Nothing in reality is infinite, neither time nor space nor anything else.
Infinity is not applicable to real variables, but only to the generation of
variables, i.e. to its *generation algorithm*
The infinity that is meant in mathematics is a loop
in an algorithm that is ended, when the wanted magnitude or precision is reached.

Our `numbers`_ are such a generated variable. It is an algorithm to create a multitude 
mappable to all kind of physical variables.
It is infinite, but this only means that our only limitation is the available time or space:

- `numbers`_ of `â„•`, generated by `(+1)*`, 
  can be selected (written down) only if not too large

- additionally a number in the `continuum`_, the `real numbers`_, `â„` 
  can be selected only with a limited precision. 

.. admonition:: Infinity

  Infinity is a practical notation (for the deferred decision about the stop time)
  of an algorithm with at least one loop.

The `continuum`_ `â„` is not only generated by an algorithm
but also consist of algorithms.
Operations on `extensive physical values`_ (quantities)
are mapped to operations on the numbers and then made part of the numbers
to form reusable `algebraic structures`_ like `groups`_  (addition) 
and `fields`_ (addition and multiplication).

- Addition to the size of an extensive value
- Multiplication: Independent extensive values are variables 
  independently selectable from. One can form the `cartesian product`_.
  Multiplication gives the size of `AxB`.

So `numbers`_ are algorithms and it turns out that some of them 
do not have finite time complexity.
For example, `âˆš2`, the diagonal of a unit square, 
is an algorithm which involves an infinite loop (open loop).
That the algorithm never ends is synonymous to: `âˆš2` does not exist in `â„š`,
but by including such algorithms we make the `completion`_ of `â„š`, 
which is then called the `real numbers`_ `â„`:
`â„=â„šâˆªð•`. The `irrational numbers`_ `ð•` and `rational numbers`_ `â„š` are `dense`_ in `â„`.

.. admonition:: Why include infinite loops?

  They in principle never end and thus they need to be aborted, and then we are
  still in `â„š`, i.e. the `limit points`_ practially don't exist.
  We can get out of this dead end by not talking any more about the `limit points`_
  but rather about the algorithm: `âˆš2` as an algorithm is different than `1.4142135623730951`.

  By including the algorithms the statements given by the `algebraic structures`_
  become more general. We have less limitations when making new calculations (`closure`_).

Because the `limit points`_ can actually never be reached, i.e. do not exist,
one must be careful about calculating with "algorithms", i.e. in `â„`,
when dealing with `0` and `âˆž`.
`0/0` can be any number, but it is still the foundation of `calculus`_.
It matters how one approaches 0. `L'HÃ´pital's rule`_ and in general
`asymptotics`_ helps then to find the limit. The same is true for `âˆž` (infinitely large).
`âˆž/âˆž` can be any number as well.
By a linear definition `0 = \lim_{nâ†’0} n` and `âˆž = \lim_{nâ†’âˆž} n` one could
write `âˆž/âˆž=1`, `0/0=1` and `(1+1/âˆž)^âˆž = e`.
Because `1/âˆž` is approaching `0` slower than linearly, we have, `0âˆž=0`.
`âˆž+1=âˆž, `3 âˆž= (3+0) âˆž = 3 âˆž`.
But to acknowledge `L'HÃ´pital's rule`_ we would have
`3âˆž â‰  âˆž` and `3\cdot 0â‰ 0`, which is not consistent with `â„š`, 
thus `0/0` and `âˆž/âˆž` is not defined in `â„`.


.. admonition:: `â„š` vs `â„`
  
   In `â„š=\{a/b|a,bâˆˆâ„¤,bâ‰ 0\}`, if one allows `a_iâˆˆâ„¤` and `b_iâˆˆâ„¤` to go to `Â±âˆž`
   in any possible way, also nonlinearly, i.e. if one admits `sequences`_ in this way, 
   then one defines only a subset of `â„`. The reason is not so much proofs like

   `âˆš2=a/b â‡’ 2=a^2/b^2 â‡’ a^2` even `â‡’ a` even `â‡’ b` even `â‡’ a/b\not\in â„š`

   which hinges on 

      if `a^2` is even then `a` is even
    
   and it is questionable,
   whether that can be done if we can't reach `âˆž`. Remember: `âˆž+1=âˆž`.

   It is rather the comprehensive definition of `â„` to comprise all thinkable
   sequences that approach a number as one `equivalence class`_.


Infinity and Information
------------------------

The information of a variable is basically the number of values.
If the values of the variable are *generated* by an algorithm,
then one moves the complexity (the size, the information) 
to the number of time steps needed to generate the values. 

.. admonition:: `algorithmic complexity`_

  `Kolmogorov complexity`_ looks only at the length of the algorithm and neglects the
  time. In the general `descriptive complexity`_ theory the time is considered, though,
  via `complexity classes`_.

The information of an infinite variable in bits is always infinite,
but one can further classify them via their `algorithmic complexity`_,
i.e. via their number of nested endless loops.

- `â„•` has one loop and so do `â„¤` and `â„š`, because they have a `bijection`_ to `â„•`.

- `â„` has two nested loops, infinitely `dense-in-itself`_ and `unbounded`_. 
  One can think of writing a real number with infinite but countable binary digits
  and thus can conclude that the `cardinality of the real numbers`_ is `2^â„•`.
  Every ever so small interval in `â„` is also of the same size.  See also 
  `continuum hypothesis`_

.. admonition:: axiom of choice

  It is *not* possible to choose *all* elements from an infinite variable,
  because it would need infinite information and/or infinite time.  One therefore
  resorts to make `choice an axiom`_ to still be able to reason about such sets.

Practically the information of a infinite variable
depends on when one chooses to stop the infinite loop, i.e. on the precision.
When modelling reality in computer software the `integer`_ type or the `floating point`_ type
is chosen according to the needed precision.
If they are not enough, one can use `arbitrary precission`_ libraries.

Infinity and Topology
---------------------

In `â„` even a normal `1` means `1.\bar{0}`.  The latter is an algorithm that never
ends. The short `1` chooses an element of `â„•` with `variable length coding`_.
The presence of *infinitely* close other numbers in `â„` asks for a method to
distinguish the `1` from them. This is done by an algorithm that
produces numbers ever closer to `1`. At a certain step, e.g. `1.000n`, the `n` 
is chosen to be `0`, instead of `1` to `9`. Every step generates a variable
to allow a further choice. This infinite loop is called *open*. 

.. admonition:: open

    *open* can be interpreted as *open ended infinite loop*.  Open ended in the
    sense that we will decide later, when to get out of it. 

The objective of an open loop is to define an element `x` by approaching it.
The intermediate steps of the loop form a `neighborhood`_ of `x`.
`x` is defined by the algorithm and is included in the set: `topological closure`_.

The definition of elements is given by the `separation axioms`_:

- `T0`_ defines a point `x` (element, value) via neighborhoods as described

- `T1`_ is when, of any two points, one has a neighborhood not containing the other

- `T2`_ is when any two points can be distinguished by disjoint neighborhoods.
  Every `filter`_ and every `net`_ has a unique limit.

If the closure of a set has missed a point and that point is separated from the
`closed`_ set by a neighborhood, then this is a `regular space`_. A regular space
is `metrizable`_. 

`Cauchy convergence`_ and `completeness`_ is generalized with the `uniform space`_
that is built on top of axioms equivalent to a `pseudometric`_, where two 
elements *not necessarily* need to have a distance.

If in the topology we have a `metric`_ a neighborhood conveniently is defined as an `open ball`_.

All these concepts to define `closeness`_ can be visualized with a finite `FCA`_ lattice
and then be generated to finer ones ad infinitum.

.. admonition:: space vs time

    Neighborhood is normally mapped to our sense of physical space, but this
    provokes the misleading idea that more is selected at the same time. 
    It is better to map a neighborhood to our sense of time, 
    because that better depicts the fact
    that the points' only reason to occur together, is the selection process
    itself. We look at one selection process at a time.
    *open* makes this selection process an open ended loop. It stands for 
    the older notation `x = \lim_{nâ†’âˆž}x_n`.
    "`f: Aâ†’B` is continous if an open `XâŠ‚B` has an open `f^{-1}(X)âŠ‚A`"
    is the same as `\lim_{nâ†’âˆž}f(x_n)=f(x)`. 
    With a `metric`_ one can also say "For every `Î´>|f(x_n)-f(x)|` there is an `Îµ>|x_n-x|`".
    Note also that neighborhood does not imply nearness in the metric sense,
    but rather in the set containment sense.


.. admonition:: `compact`_

    Every *open* cover has a *finite* subcover.

    With this property we can replace an infinite union in the topology
    by a finite union and thus make statements about the whole set 
    that wouldn't otherwise be possible, because *infinity* can never be reached.

    That a `bounded`_ set is `closed`_ or vice versa can be proved with compactness.


Usefulness of Infinity
----------------------

- One such use mentioned already is to have a versatile multitude to map
  all kind of real variables to.

- `Variables`_ do not exist alone. They exist because of other variables.  The
  functional dependence is a general characterization of the system, not so
  much the size of the variables (information), which changes from system to
  system. With the infinity as defined here one makes a simulation with
  generated variables to the wanted precision.  The algorithm needs less memory
  and simulations can be done with minimal generated variables.  So this
  `analytic description`_ altogether saves a lot of memory.

- One does not need to use by chance numbers

  When a physicist liberally uses infinity in his description of the world, 
  this is an idealization justified by the wanted precision.  
  For example an infinite distance could be a few centimeters when describing an
  atomic scale phenomenon. It is this idea that makes him use `âˆž` instead
  of a by chance distance like 2cm or 3cm.

- One can make more general statements. Such statements are shorter, 
  i.e. need less space (information, complexity).
  
  In a general statement the precision is unknown and so the decision about it
  needs to be deferred. 

  For example in a NaCl crystal the diagonal will need one precision for KBr another one.

- There is often no finite algorithm to describe certain things,
  like the length of the diagonal of a square (`âˆš2`).

- `Trial and error`_ is a basic principle because it follows from selection.
  This is an infinity iterative algorithm that is stopped when content with the result.
  Obviously this has many applications.


.. _`Variables`: `space`_
.. _`space`: http://rolandpuntaier.blogspot.co.at/2017/02/from-variable-to-structure.html
.. _`unbounded`: `bounded`_
.. _`topological structure`: http://rolandpuntaier.blogspot.co.at/2017/02/from-variable-to-structure.html
.. _`FCA`: http://rolandpuntaier.blogspot.com/2015/06/fca.html
.. _`variable`: http://rolandpuntaier.blogspot.com/2015/03/what-is-information.html
.. _`lattice`: https://en.wikipedia.org/wiki/Lattice_(order)
.. _`topology`: https://en.wikipedia.org/wiki/Topological_space#Definition
.. _`extensive physical values`: `measure`_
.. _`measure`: http://rolandpuntaier.blogspot.com/2017/04/measure.html
.. _`numbers`: http://mamchecker.appspot.com/en/?r.ci
.. _`continuum`: https://en.wikipedia.org/wiki/Continuum_(set_theory)
.. _`continuum hypothesis`: https://en.wikipedia.org/wiki/Continuum_hypothesis
.. _`real numbers`: https://en.wikipedia.org/wiki/Real_number
.. _`algebraic structures`: https://en.wikipedia.org/wiki/Algebraic_structure
.. _`groups`: https://en.wikipedia.org/wiki/Group_(mathematics)
.. _`fields`: https://en.wikipedia.org/wiki/Field_(mathematics)
.. _`cartesian product`: https://en.wikipedia.org/wiki/Cartesian_product
.. _`completion`: https://en.wikipedia.org/wiki/Real_number#Completeness
.. _`irrational numbers`: https://en.wikipedia.org/wiki/Irrational_number
.. _`limit points`: https://en.wikipedia.org/wiki/Limit_point
.. _`calculus`: https://en.wikipedia.org/wiki/Calculus
.. _`L'HÃ´pital's rule`: https://en.wikipedia.org/wiki/L'HÃ´pital's_rule
.. _`asymptotics`: https://en.wikipedia.org/wiki/Asymptotic_analysis
.. _`equivalence class`: https://en.wikipedia.org/wiki/Equivalence_class
.. _`Kolmogorov complexity`: https://en.wikipedia.org/wiki/Kolmogorov_complexity
.. _`descriptive complexity`: https://en.wikipedia.org/wiki/Descriptive_complexity_theory 
.. _`complexity classes`: https://en.wikipedia.org/wiki/Complexity_class
.. _`algorithmic complexity`: https://en.wikipedia.org/wiki/Algorithmic_information_theory
.. _`bijection`: http://math.stackexchange.com/questions/182236/why-do-the-rationals-integers-and-naturals-all-have-the-same-cardinality
.. _`dense-in-itself`: https://en.wikipedia.org/wiki/Dense-in-itself
.. _`cardinality of the real numbers`: https://en.wikipedia.org/wiki/Cardinality_of_the_continuum
.. _`choice an axiom`: https://en.wikipedia.org/wiki/Axiom_of_choice
.. _`integer`: https://en.wikipedia.org/wiki/Integer_(computer_science)
.. _`floating point`: https://en.wikipedia.org/wiki/IEEE_floating_point
.. _`arbitrary precission`: https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software
.. _`variable length coding`: https://en.wikipedia.org/wiki/Variable-length_code
.. _`neighborhood`: https://en.wikipedia.org/wiki/Neighbourhood_(mathematics)
.. _`closed`: `topological closure`_
.. _`topological closure`: https://en.wikipedia.org/wiki/Closure_(topology)
.. _`separation axioms`: https://en.wikipedia.org/wiki/Separation_axiom
.. _`T0`: https://en.wikipedia.org/wiki/Kolmogorov_space
.. _`T1`: https://en.wikipedia.org/wiki/T1_space
.. _`T2`: https://en.wikipedia.org/wiki/Hausdorff_space
.. _`filter`: https://en.wikipedia.org/wiki/Filter_(mathematics)
.. _`net`: https://en.wikipedia.org/wiki/Net_(topology)
.. _`regular space`: https://en.wikipedia.org/wiki/Regular_space
.. _`metrizable`: https://en.wikipedia.org/wiki/Metrization_theorem
.. _`Cauchy convergence`: https://en.wikipedia.org/wiki/Cauchy_sequence
.. _`completeness`: https://en.wikipedia.org/wiki/Cauchy_sequence#Completeness
.. _`uniform space`: https://en.wikipedia.org/wiki/Uniform_space
.. _`pseudometric`: https://en.wikipedia.org/wiki/Pseudometric_space
.. _`open ball`: https://en.wikipedia.org/wiki/Ball_(mathematics)
.. _`closeness`: https://en.wikipedia.org/wiki/Closeness_(mathematics)
.. _`metric`: https://en.wikipedia.org/wiki/Metric_(mathematics)#Definition
.. _`compact`: https://en.wikipedia.org/wiki/Compact_space
.. _`bounded`: https://en.wikipedia.org/wiki/Bounded_set_(topological_vector_space)
.. _`analytic description`: https://en.wikipedia.org/wiki/Mathematical_analysis
.. _`Trial and error`: https://en.wikipedia.org/wiki/Trial_and_error
.. _`rational numbers`: https://en.wikipedia.org/wiki/Rational_number
.. _`dense`: https://en.wikipedia.org/wiki/Dense_set
.. _`closure`: https://en.wikipedia.org/wiki/Closure_(mathematics)
.. _`sequences`: https://en.wikipedia.org/wiki/Sequence#Formal_definition_and_basic_properties
.. _`action`: https://en.wikipedia.org/wiki/Action_(physics)
.. _`h`: https://en.wikipedia.org/wiki/Planck_constant

